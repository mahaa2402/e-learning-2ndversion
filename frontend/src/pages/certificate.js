import React, { useEffect, useState, useRef } from 'react';
import { PDFDocument, StandardFonts, rgb } from 'pdf-lib';
import pretestTemplate from '../assets/Pre assesment.pdf';
import preTrainingTemplate from '../assets/VISTA_Pre_Training_Certificate_Final 3.pdf';
import postTrainingTemplate from '../assets/VISTA_Post_Training_Certificate_Final 2.pdf';
import { useNavigate, useLocation } from 'react-router-dom';
import './certificate.css';
import { API_ENDPOINTS } from '../config/api';

const CertificatePage = () => {
  const navigate = useNavigate();
  const location = useLocation();
  
  // Check for selectedCertificate immediately (synchronously) before first render
  const initialSelectedCert = typeof window !== 'undefined' ? localStorage.getItem('selectedCertificate') : null;
  let initialCertificateData = null;
  let initialLoading = true;
  
  if (initialSelectedCert) {
    try {
      const cert = JSON.parse(initialSelectedCert);
      if (cert && (cert.courseTitle || cert.courseName)) {
        // Normalize data
        if (!cert.courseTitle && cert.courseName) {
          cert.courseTitle = cert.courseName;
        }
        if (!cert.date && cert.completionDate) {
          cert.date = cert.completionDate;
        }
        initialCertificateData = cert;
        initialLoading = false; // Don't show loading if we have the data
      }
    } catch (e) {
      console.error('Error parsing initial certificate:', e);
    }
  }
  
  const [certificateData, setCertificateData] = useState(initialCertificateData);
  const [pdfPreviewUrl, setPdfPreviewUrl] = useState(null);
  const [loading, setLoading] = useState(initialLoading);
  const [error, setError] = useState(null);
  const [success, setSuccess] = useState(!!initialCertificateData);
  const [courseCompleted, setCourseCompleted] = useState(!!initialCertificateData);
  const [courseId, setCourseId] = useState(null);
  const [lessonId, setLessonId] = useState(null);
  const [refreshedModuleData, setRefreshedModuleData] = useState(null);
  const [pdfGenerated, setPdfGenerated] = useState(false);
  const hasProcessedCertificate = useRef(!!initialCertificateData); // Mark as processed if we have initial data
  const lastLocationKey = useRef(location.key); // Track location key to detect navigation
  const [autoGeneratedPdfUrl, setAutoGeneratedPdfUrl] = useState(null);

  // Get employee data from localStorage or user session
  const getEmployeeData = () => {
    let employeeName = "Employee Name";
    let employeeId = "Unknown ID";

    // Determine current user role from session (if available)
    let isAdmin = false;
    const userSessionRaw = localStorage.getItem('userSession');
    if (userSessionRaw) {
      try {
        const user = JSON.parse(userSessionRaw);
        isAdmin = user.role === 'admin';
        // If not admin, prefer the logged-in user's info
        if (!isAdmin) {
          employeeName = user.name || user.email?.split('@')[0] || employeeName;
          employeeId = user._id || user.id || employeeId;
        }
      } catch (e) {
        console.error('Error parsing user session:', e);
      }
    }

    // Only use viewingEmployee* keys when the current user is an admin
    const viewingEmployeeName = localStorage.getItem('viewingEmployeeName');
    const viewingEmployeeId = localStorage.getItem('viewingEmployeeId');
    if (isAdmin && viewingEmployeeName) {
      employeeName = viewingEmployeeName;
    }
    if (isAdmin && viewingEmployeeId) {
      employeeId = viewingEmployeeId;
    }

    // If not admin, remove any stale viewingEmployee keys to avoid showing previous admin's selection
    if (!isAdmin) {
      localStorage.removeItem('viewingEmployeeName');
      localStorage.removeItem('viewingEmployeeId');
      localStorage.removeItem('viewingEmployeeEmail');
    }

    // Fallback to individual localStorage items if still missing
    if (employeeName === "Employee Name") {
      employeeName = localStorage.getItem('employeeName') || "Employee Name";
    }
    if (employeeId === "Unknown ID") {
      employeeId = localStorage.getItem('employeeId') || "Unknown ID";
    }
    
    return { employeeName, employeeId };
  };

  const { employeeName, employeeId } = getEmployeeData();

  useEffect(() => {
    console.log('ü™™ Certificate page mounted:', { initialCertificateData, savedCourseId: localStorage.getItem('certificateCourseId'), savedLessonId: localStorage.getItem('certificateLessonId') });
    // Check if admin came from certificate detail page
    const cameFromCertificateDetail = localStorage.getItem('cameFromCertificateDetail') === 'true';
    const certificateDetailEmployeeId = localStorage.getItem('certificateDetailEmployeeId');
    
    // Check if user is admin
    const userSession = localStorage.getItem('userSession');
    let isAdmin = false;
    if (userSession) {
      try {
        const user = JSON.parse(userSession);
        isAdmin = user.role === 'admin';
      } catch (e) {
        console.error('Error parsing user session:', e);
      }
    }
    
    // Prevent browser back button from going to quiz page
    const savedCourseId = localStorage.getItem('certificateCourseId');
    const savedLessonId = localStorage.getItem('certificateLessonId');
    
    // Set courseId and lessonId state
    if (savedCourseId) setCourseId(savedCourseId);
    if (savedLessonId) setLessonId(savedLessonId);
    
    // Handle browser back button
    const handlePopState = (event) => {
      // If admin came from certificate detail page, navigate back there
      if (isAdmin && cameFromCertificateDetail && certificateDetailEmployeeId) {
        navigate(`/certificatedetail/${certificateDetailEmployeeId}`, { replace: true });
        // Clear the flag
        localStorage.removeItem('cameFromCertificateDetail');
        localStorage.removeItem('certificateDetailEmployeeId');
      } else if (savedCourseId && savedLessonId) {
        // For regular users, navigate to lesson page instead of going back to quiz
        navigate(`/course/${savedCourseId}/lesson/${savedLessonId}`, { replace: true });
      }
    };
    
    window.addEventListener('popstate', handlePopState);
    
    // Replace current history entry to prevent going back to quiz
    if (savedCourseId && savedLessonId && !(isAdmin && cameFromCertificateDetail)) {
      // Replace the quiz page entry with lesson page in history (only for regular users)
      window.history.replaceState(
        { page: 'lesson', courseId: savedCourseId, lessonId: savedLessonId },
        '',
        `/course/${savedCourseId}/lesson/${savedLessonId}`
      );
      
      // Then push certificate page
      window.history.pushState(
        { page: 'certificate', courseId: savedCourseId, lessonId: savedLessonId },
        '',
        window.location.pathname
      );
    } else if (isAdmin && cameFromCertificateDetail && certificateDetailEmployeeId) {
      // For admin from certificate detail, push certificate page with proper history
      window.history.pushState(
        { page: 'certificate', fromDetail: true, employeeId: certificateDetailEmployeeId },
        '',
        window.location.pathname
      );
    }
    
    return () => {
      window.removeEventListener('popstate', handlePopState);
    };
  }, [navigate]);

  // Cleanup effect: Clear selectedCertificate when component unmounts (user navigates away)
  useEffect(() => {
    return () => {
      // Only clear if we're actually navigating away (not just re-rendering)
      // This ensures selectedCertificate is available for the next visit
      // We'll clear it when a new certificate is selected instead
      console.log('üßπ Certificate page unmounting - keeping selectedCertificate for next visit');
    };
  }, []);

  // Convert an image blob (webp or other) to PNG bytes using a canvas as fallback so pdf-lib can embed it
  const convertImageToPngBytes = async (imageUrl) => {
    try {
      const response = await fetch(imageUrl);
      const blob = await response.blob();
      // If createImageBitmap is available, use it (faster and more robust)
      let bitmap;
      if (typeof createImageBitmap === 'function') {
        bitmap = await createImageBitmap(blob);
      } else {
        // Fallback for older browsers: load into Image and draw to canvas when loaded
        bitmap = await new Promise((resolve, reject) => {
          const image = new Image();
          image.onload = () => resolve(image);
          image.onerror = reject;
          image.src = URL.createObjectURL(blob);
        });
      }

      // Draw on canvas
      const canvas = document.createElement('canvas');
      canvas.width = bitmap.width;
      canvas.height = bitmap.height;
      const ctx = canvas.getContext('2d');
      ctx.drawImage(bitmap, 0, 0);
      // Convert to PNG data URL
      const dataURL = canvas.toDataURL('image/png');
      const base64 = dataURL.split(',')[1];
      const binary = atob(base64);
      const bytes = new Uint8Array(binary.length);
      for (let i = 0; i < binary.length; i++) {
        bytes[i] = binary.charCodeAt(i);
      }
      return bytes;
    } catch (err) {
      console.error('Image conversion failed:', err);
      return null;
    }
  };

  // Utility to split long course names to two lines that fit within the max width
  const splitTextToFit = (text, font, maxWidth, maxLines=2, initialSize=36) => {
    if (!text) return [text];
    const words = text.split(' ');
    const lines = [''];
    for (let w of words) {
      const current = lines[lines.length - 1];
      const trial = current ? `${current} ${w}` : w;
      const width = font.widthOfTextAtSize(trial, initialSize);
      if (width <= maxWidth) {
        lines[lines.length - 1] = trial;
      } else {
        if (lines.length < maxLines) {
          lines.push(w);
        } else {
          // Append to last line and continue, it will overflow but keep minimal
          lines[lines.length-1] += ' ' + w;
        }
      }
    }
    return lines;
  };

  // Generate PDF bytes from template and overlayed data
  const generatePdfBytes = async () => {
    // Determine certificate type (pre-test vs post-test)
    // Check location.state first, then check localStorage for fromPreTest flag
    const isPreTest = location.state?.fromPreTest || localStorage.getItem('fromPreTest') === 'true';
    const certType = isPreTest ? 'pre' : 'pro';
    
    // Select the correct template based on certificate type
    let templateToUse;
    if (certType === 'pre') {
      templateToUse = preTrainingTemplate;
    } else {
      templateToUse = postTrainingTemplate;
    }
    
    const existingPdfBytes = await fetch(templateToUse).then(r => r.arrayBuffer());
    const pdfDoc = await PDFDocument.load(existingPdfBytes);

    // Embed standard font
    const helveticaFont = await pdfDoc.embedFont(StandardFonts.HelveticaBold);
    const helveticaRegular = await pdfDoc.embedFont(StandardFonts.Helvetica);
    const pages = pdfDoc.getPages();
    const firstPage = pages[0];
    const { width, height } = firstPage.getSize();

    // Get certificate data - use current values from component state
    // These are accessible via closure when function is called
    const currentCourseTitle = 
      location.state?.certificateDataOverride?.courseTitle ||
      certificateData?.courseTitle ||
      certificateData?.courseName ||
      courseTitle ||
      'Course Title';
    
    // Helper function to format date as DD/MM/YYYY
    const formatDateLocal = (dateValue) => {
      if (!dateValue) {
        const today = new Date();
        const day = String(today.getDate()).padStart(2, '0');
        const month = String(today.getMonth() + 1).padStart(2, '0');
        const year = today.getFullYear();
        return `${day}/${month}/${year}`;
      }
      if (typeof dateValue === 'string') {
        const parsedDate = new Date(dateValue);
        if (!isNaN(parsedDate.getTime())) {
          const day = String(parsedDate.getDate()).padStart(2, '0');
          const month = String(parsedDate.getMonth() + 1).padStart(2, '0');
          const year = parsedDate.getFullYear();
          return `${day}/${month}/${year}`;
        }
        return dateValue;
      }
      if (dateValue instanceof Date) {
        const day = String(dateValue.getDate()).padStart(2, '0');
        const month = String(dateValue.getMonth() + 1).padStart(2, '0');
        const year = dateValue.getFullYear();
        return `${day}/${month}/${year}`;
      }
      return dateValue;
    };
    
    // Fetch date from certificate table - prioritize certificateData.date or completionDate
    const currentDate = 
      certificateData?.date 
        ? formatDateLocal(certificateData.date)
        : (certificateData?.completionDate 
          ? formatDateLocal(certificateData.completionDate)
          : (location.state?.certificateDataOverride?.completionDate 
            ? formatDateLocal(location.state.certificateDataOverride.completionDate)
            : (date || formatDateLocal(new Date()))));
    
    const currentEmployeeName = employeeName || certificateData?.employeeName || 'Employee Name';

    // Draw text in center positions (adjust if needed)
    const name = currentEmployeeName;
    const course = currentCourseTitle;
    const dateText = currentDate;

    const drawCenteredText = (text, y, font, size = 48) => {
      const textWidth = font.widthOfTextAtSize(text, size);
      const x = (width - textWidth) / 2;
      firstPage.drawText(text, {
        x,
        y,
        size,
        font,
        color: rgb(0.06, 0.06, 0.06),
        opacity: 1
      });
    };

    // Positions chosen relative to page size; tweak if needed
    // Move employee name slightly below (lower Y value = lower on page)
    const nameY = height * 0.54; // moved slightly below
    const courseY = height * 0.41; // position for course name + "training program" - moved slightly below
    // Date should be above the "DATE" label in the footer area
    // Footer area is typically around 0.20-0.25 of page height from bottom
    // DATE label is around 0.20, so date should be at 0.22-0.24 to be above it
    const dateY = height * 0.28; // positioned above the DATE label in footer
       
    // Maximum text width area (centered) - we avoid overlay with left or right visuals
    const maxTextWidth = width * 0.7;

    // Adjust name font size to fit max width
    let nameSize = 64;
    const nameWidth = helveticaFont.widthOfTextAtSize(name, nameSize);
    if (nameWidth > maxTextWidth) {
      nameSize = Math.max(30, Math.floor(nameSize * maxTextWidth / nameWidth));
    }
    drawCenteredText(name, nameY, helveticaFont, nameSize);

    // Course title with "training program" - place on 3rd line
    const courseMaxSize = 36;
    const courseWithTraining = `${course} Training Program`;
    const courseLines = splitTextToFit(courseWithTraining, helveticaRegular, maxTextWidth, 2, courseMaxSize);
    let courseSize = courseMaxSize;
    for (const line of courseLines) {
      const wLine = helveticaRegular.widthOfTextAtSize(line, courseSize);
      if (wLine > maxTextWidth) {
        const ratio = maxTextWidth / wLine;
        courseSize = Math.max(18, Math.floor(courseSize * ratio));
      }
    }
    const lineSpacing = courseSize + 6;
    
    // Draw course name + "training program" on 3rd line (after employee name)
    courseLines.forEach((line, idx) => {
      const y = courseY - ((courseLines.length - 1) * lineSpacing / 2) + (idx * lineSpacing);
      drawCenteredText(line, y, helveticaFont, courseSize);
    });

    // Date text - right block aligned, placed above the DATE printed label
    let dateSize = 28;
    const dateWidth = helveticaRegular.widthOfTextAtSize(dateText, dateSize);
    // Move date to the right side to match template
    const rightBlockX = width * 0.82; // closer to right edge - tuned to align with template
    // Use smaller max width for date area
    const dateMaxWidth = width * 0.3;
    if (dateWidth > dateMaxWidth) {
      dateSize = Math.max(10, Math.floor(dateSize * dateMaxWidth / dateWidth));
    }
    // Draw the date right-aligned
    const dateX = width * 0.37;   // adjust as needed
    firstPage.drawText(dateText, {
      x: dateX,
      y: dateY,
      size: dateSize,
      font: helveticaRegular,
      color: rgb(0.06, 0.06, 0.06),
      opacity: 1
    });

    // Signature image removed as per user request - no e-signature will be displayed

    // Return PDF bytes
    const pdfBytes = await pdfDoc.save();
    return pdfBytes;
  };

  useEffect(() => {
    const initializeCertificate = async () => {
      // Check if this is a new navigation (location key changed)
      const isNewNavigation = location.key !== lastLocationKey.current;
      if (isNewNavigation) {
        console.log('üîÑ New navigation detected, resetting processed flag');
        lastLocationKey.current = location.key;
        hasProcessedCertificate.current = false;
        
        // Re-check for selectedCertificate on new navigation
        const newSelectedCert = localStorage.getItem('selectedCertificate');
        if (newSelectedCert) {
          try {
            const cert = JSON.parse(newSelectedCert);
            if (cert && (cert.courseTitle || cert.courseName)) {
              // Normalize data
              if (!cert.courseTitle && cert.courseName) {
                cert.courseTitle = cert.courseName;
              }
              if (!cert.date && cert.completionDate) {
                cert.date = cert.completionDate;
              }
              // Set certificate data immediately
              setCertificateData(cert);
              setCourseCompleted(true);
              setSuccess(true);
              setLoading(false);
              hasProcessedCertificate.current = true;
              localStorage.removeItem('courseCompleted');
              localStorage.removeItem('completedCourseName');
              localStorage.removeItem('lastGeneratedCertificate');
              console.log('üéâ Certificate loaded on new navigation:', cert);
              return; // Exit early - certificate loaded
            }
          } catch (e) {
            console.error('Error parsing certificate on new navigation:', e);
          }
        }
        
        // If no certificate found, reset state for fresh load
        setCertificateData(null);
        setLoading(true);
        setSuccess(false);
        setCourseCompleted(false);
      }
      
      // Reset the processed flag if selectedCertificate has changed
      const currentSelectedCert = localStorage.getItem('selectedCertificate');
      if (currentSelectedCert && hasProcessedCertificate.current && certificateData && !isNewNavigation) {
        // Check if this is a different certificate by comparing
        try {
          const newCert = JSON.parse(currentSelectedCert);
          const existingCert = certificateData;
          // If course titles don't match, it's a new certificate - reset the flag
          if (existingCert && newCert.courseTitle !== existingCert.courseTitle) {
            console.log('üîÑ New certificate detected, resetting processed flag');
            hasProcessedCertificate.current = false;
            setCertificateData(null);
            setLoading(true);
            setSuccess(false);
            setCourseCompleted(false);
          } else if (existingCert && newCert.courseTitle === existingCert.courseTitle) {
            // Same certificate, already processed
            console.log('‚úÖ Same certificate already loaded');
            localStorage.removeItem('courseCompleted');
            localStorage.removeItem('completedCourseName');
            localStorage.removeItem('lastGeneratedCertificate');
            return;
          }
        } catch (e) {
          console.error('Error comparing certificates:', e);
        }
      }
      
      // If we already have certificate data from initial check and it's not a new navigation, just clear temporary flags and return
      if (certificateData && hasProcessedCertificate.current && !currentSelectedCert && !isNewNavigation) {
        console.log('‚úÖ Certificate already loaded from initial check');
        localStorage.removeItem('courseCompleted');
        localStorage.removeItem('completedCourseName');
        localStorage.removeItem('lastGeneratedCertificate');
        return;
      }
      
      // Prevent multiple executions (React StrictMode in development) - but allow if new certificate or new navigation
      if (hasProcessedCertificate.current && certificateData && !isNewNavigation) {
        console.log('‚ö†Ô∏è Certificate already processed, skipping...');
        return;
      }
      
      // IMMEDIATE CHECK: Check for selectedCertificate FIRST before any async operations
      const selectedCertificate = localStorage.getItem('selectedCertificate');
      if (selectedCertificate) {
        try {
          console.log('üìã Found selectedCertificate - displaying immediately');
          const certificate = JSON.parse(selectedCertificate);
          
          // Normalize certificate data structure
          if (certificate) {
            if (!certificate.courseTitle && certificate.courseName) {
              certificate.courseTitle = certificate.courseName;
            }
            if (!certificate.date && certificate.completionDate) {
              certificate.date = certificate.completionDate;
            }
            if (certificate.employeeName && !localStorage.getItem('viewingEmployeeName')) {
              localStorage.setItem('viewingEmployeeName', certificate.employeeName);
            }
          }
          
          // Validate and display immediately
          if (certificate && (certificate.courseTitle || certificate.courseName)) {
            setCertificateData(certificate);
            setCourseCompleted(true);
            setSuccess(true);
            setLoading(false);
            hasProcessedCertificate.current = true;
            
            // Get courseId and lessonId for back navigation
            const certCourseId = localStorage.getItem('certificateCourseId');
            const certLessonId = localStorage.getItem('certificateLessonId');
            if (certCourseId) setCourseId(certCourseId);
            if (certLessonId) setLessonId(certLessonId);
            
            // DON'T clear selectedCertificate here - keep it for navigation consistency
            // Only clear other temporary flags
            localStorage.removeItem('courseCompleted');
            localStorage.removeItem('completedCourseName');
            localStorage.removeItem('lastGeneratedCertificate');
            
            console.log('üéâ Certificate displayed instantly:', certificate);
            return; // Exit immediately - no API calls
          }
        } catch (error) {
          console.error('‚ùå Error parsing selected certificate:', error);
          // Continue to normal flow if parsing fails
        }
      }
      
      try {
        setLoading(true);
        setError(null);

        // Get courseId and lessonId from localStorage (set when navigating from lesson page)
        const savedCourseId = localStorage.getItem('certificateCourseId');
        const savedLessonId = localStorage.getItem('certificateLessonId');
        if (savedCourseId) setCourseId(savedCourseId);
        if (savedLessonId) setLessonId(savedLessonId);

        // Check if this is a newly completed course or a selected certificate from dashboard
        const isCourseCompleted = localStorage.getItem('courseCompleted') === 'true';
        const completedCourseName = localStorage.getItem('completedCourseName');
        const lastGeneratedCertificate = localStorage.getItem('lastGeneratedCertificate');

        // Priority 1: Check for lastGeneratedCertificate (for newly completed courses)

        // Priority 2: Check if this is a newly completed course with generated certificate
        if (isCourseCompleted && lastGeneratedCertificate) {
          try {
            // Use the newly generated certificate data
            const certificate = JSON.parse(lastGeneratedCertificate);
            
            // Validate certificate has required fields
            if (!certificate || (!certificate.courseTitle && !certificate.courseName)) {
              throw new Error('Invalid certificate data: missing course title');
            }
            
            setCertificateData(certificate);
            setCourseCompleted(true);
            setSuccess(true);
            setLoading(false);
            
            // Clear the temporary data
            localStorage.removeItem('courseCompleted');
            localStorage.removeItem('completedCourseName');
            localStorage.removeItem('lastGeneratedCertificate');
            
            // Get courseId and lessonId for back navigation
            const certCourseId = localStorage.getItem('certificateCourseId');
            const certLessonId = localStorage.getItem('certificateLessonId');
            if (certCourseId) setCourseId(certCourseId);
            if (certLessonId) setLessonId(certLessonId);
            
            console.log('üéâ Displaying newly generated certificate:', certificate);
            return;
          } catch (error) {
            console.error('Error parsing last generated certificate:', error);
            // Continue to next priority instead of failing
          }
        }

        // Priority 3: Check if this is a newly completed course (from quiz completion)
        if (isCourseCompleted && completedCourseName) {
          // Get user email from token
          const token = localStorage.getItem('authToken') || localStorage.getItem('token');
          let userEmail = '';
          if (token) {
            try {
              const payload = JSON.parse(atob(token.split('.')[1]));
              userEmail = payload.email;
            } catch (e) {
              console.error('Error parsing token:', e);
            }
          }
          
          // Create a temporary certificate object for display
          const tempCertificate = {
            courseTitle: completedCourseName,
            employeeName: employeeName,
            employeeId: employeeId,
            employeeEmail: userEmail,
            date: new Date().toLocaleDateString(),
            certificateId: `CERT-${Date.now()}`,
            completionDate: new Date(),
            completedModules: ['All Modules'],
            totalModules: 1
          };
          
          setCertificateData(tempCertificate);
          setCourseCompleted(true);
          setSuccess(true);
          setLoading(false);
          
          // Clear the temporary data
          localStorage.removeItem('courseCompleted');
          localStorage.removeItem('completedCourseName');
          
          console.log('üéâ Displaying course completion certificate:', tempCertificate);
          return;
        }

        // Fallback: Try to fetch certificates from database
        // IMPORTANT: Only do this if we haven't already processed selectedCertificate
        // Check one more time if selectedCertificate was set (in case of timing issues)
        const retrySelectedCert = localStorage.getItem('selectedCertificate');
        if (retrySelectedCert) {
          console.log('‚ö†Ô∏è Found selectedCertificate in fallback, processing it...');
          try {
            const retryCert = JSON.parse(retrySelectedCert);
            if (retryCert && (retryCert.courseTitle || retryCert.courseName)) {
              if (!retryCert.courseTitle && retryCert.courseName) {
                retryCert.courseTitle = retryCert.courseName;
              }
              setCertificateData(retryCert);
              setCourseCompleted(true);
              setSuccess(true);
              setLoading(false);
              localStorage.removeItem('selectedCertificate');
              localStorage.removeItem('courseCompleted');
              localStorage.removeItem('completedCourseName');
              localStorage.removeItem('lastGeneratedCertificate');
              console.log('üéâ Displaying certificate from retry:', retryCert);
              return;
            }
          } catch (e) {
            console.error('Error parsing retry certificate:', e);
          }
        }
        
        const token = localStorage.getItem('authToken') || localStorage.getItem('token');
        
        if (!token) {
          setError('Authentication token not found. Please login again.');
          setLoading(false);
          return;
        }

        console.log('üîç Attempting to fetch certificates from database (no selectedCertificate found)...');
        
        // Get certificates from the database
        let response;
        let data;
        
        try {
          response = await fetch(API_ENDPOINTS.CERTIFICATES.GET_CERTIFICATES, {
            method: 'GET',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${token}`
            }
          });

          data = await response.json();
          console.log('üìä Certificate API response:', data);
        } catch (fetchError) {
          console.error('‚ùå Network error fetching certificates:', fetchError);
          // If it's a 404, it might be that the endpoint doesn't exist for admin users
          // Don't show error if we're viewing a selected certificate
          if (!selectedCertificate && !lastGeneratedCertificate) {
            setError('Unable to fetch certificates. Please try again.');
          }
          setLoading(false);
          return;
        }
        
        if (!response.ok) {
          if (response.status === 403) {
            setError('Session expired. Please login again.');
            // Clear invalid token
            localStorage.removeItem('authToken');
            localStorage.removeItem('token');
          } else if (response.status === 404) {
            // 404 is okay if we're viewing a selected certificate (admin viewing employee cert)
            console.log('‚ö†Ô∏è 404 from certificate API - this is normal when viewing selected certificate');
            if (!selectedCertificate && !lastGeneratedCertificate) {
              setError('Certificate endpoint not found. Please contact support.');
            }
          } else {
            console.error('‚ùå Certificate API error:', data);
            setError(data.message || 'Failed to fetch certificate');
          }
          setLoading(false);
          return;
        } else {
          if (data.success && data.certificates && data.certificates.length > 0) {
            // Use the most recent certificate
            const latestCertificate = data.certificates[0];
            setCertificateData(latestCertificate);
            setSuccess(true);
            console.log('‚úÖ Certificate fetched successfully:', latestCertificate);
          } else {
            console.log('‚ö†Ô∏è No certificates found in database');
            
            // Get user email from token
            let userEmail = '';
            if (token) {
              try {
                const payload = JSON.parse(atob(token.split('.')[1]));
                userEmail = payload.email;
              } catch (e) {
                console.error('Error parsing token:', e);
              }
            }
            
            // Try to generate certificate for completed course from localStorage first
            if (completedCourseName) {
              console.log('üîÑ Attempting to generate certificate for completed course:', completedCourseName);
              
              try {
                let generateResponse;
                try {
                  generateResponse = await fetch(API_ENDPOINTS.CERTIFICATES.CHECK_COURSE_COMPLETION, {
                    method: 'POST',
                    headers: {
                      'Content-Type': 'application/json',
                      'Authorization': `Bearer ${token}`
                    },
                    body: JSON.stringify({
                      courseName: completedCourseName,
                      userEmail: userEmail
                    })
                  });
                } catch (fetchError) {
                  console.error('‚ùå Network error checking course completion:', fetchError);
                  // Skip this attempt
                  generateResponse = null;
                }
                
                if (generateResponse && generateResponse.ok) {
                  const generateData = await generateResponse.json();
                  console.log('üéì Certificate generation response:', generateData);
                  
                  if (generateData.success && generateData.isCompleted && generateData.certificate) {
                    // Certificate was generated successfully
                    setCertificateData(generateData.certificate);
                    setCourseCompleted(true);
                    setSuccess(true);
                    
                    // Clear the temporary data
                    localStorage.removeItem('courseCompleted');
                    localStorage.removeItem('completedCourseName');
                    
                    console.log('‚úÖ Certificate generated and displayed:', generateData.certificate);
                    setLoading(false);
                    return;
                  } else {
                    console.log('‚ö†Ô∏è Certificate generation failed:', generateData?.message);
                  }
                } else if (generateResponse && generateResponse.status === 404) {
                  console.log('‚ö†Ô∏è Certificate endpoint returned 404 - this is normal for admin viewing employee certs');
                }
              } catch (generateError) {
                console.error('‚ùå Error generating certificate:', generateError);
              }
            }
            
            // If no certificate from localStorage course, check all common courses for completion
            // BUT ONLY if we don't have selectedCertificate (admin viewing employee cert)
            const hasSelectedCert = localStorage.getItem('selectedCertificate');
            if (hasSelectedCert) {
              console.log('‚ö†Ô∏è selectedCertificate found during course check, skipping API calls');
              // Try to process it one more time
              try {
                const retryCert = JSON.parse(hasSelectedCert);
                if (retryCert && (retryCert.courseTitle || retryCert.courseName)) {
                  if (!retryCert.courseTitle && retryCert.courseName) {
                    retryCert.courseTitle = retryCert.courseName;
                  }
                  setCertificateData(retryCert);
                  setCourseCompleted(true);
                  setSuccess(true);
                  setLoading(false);
                  localStorage.removeItem('selectedCertificate');
                  localStorage.removeItem('courseCompleted');
                  localStorage.removeItem('completedCourseName');
                  localStorage.removeItem('lastGeneratedCertificate');
                  console.log('üéâ Displaying certificate from course check retry:', retryCert);
                  return;
                }
              } catch (e) {
                console.error('Error parsing certificate in course check:', e);
              }
            }
            
            if (!certificateData && userEmail && !hasSelectedCert) {
              console.log('üîç Checking all courses for completion...');
              
              // List of common courses to check
              const commonCourses = ['ISP', 'GDPR', 'POSH', 'Factory Act', 'Welding', 'CNC', 'Excel', 'VRU'];
              
              // Try to generate certificate for any completed course
              for (const courseName of commonCourses) {
                try {
                  console.log(`üîç Checking if ${courseName} is completed...`);
                  let generateResponse;
                  let generateData;
                  
                  try {
                    generateResponse = await fetch(API_ENDPOINTS.CERTIFICATES.CHECK_COURSE_COMPLETION, {
                      method: 'POST',
                      headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${token}`
                      },
                      body: JSON.stringify({
                        courseName: courseName,
                        userEmail: userEmail
                      })
                    });
                    
                    if (generateResponse && generateResponse.ok) {
                      generateData = await generateResponse.json();
                    } else {
                      console.log(`‚ö†Ô∏è ${courseName} check returned ${generateResponse?.status || 'error'}`);
                      // Continue to next course
                      continue;
                    }
                  } catch (error) {
                    console.log(`‚ö†Ô∏è Error checking ${courseName}:`, error.message);
                    // Continue to next course
                    continue;
                  }
                  
                  if (generateResponse && generateResponse.ok && generateData && generateData.success && generateData.isCompleted && generateData.certificate) {
                    console.log(`‚úÖ Found completed course: ${courseName}, certificate generated`);
                    setCertificateData(generateData.certificate);
                    setCourseCompleted(true);
                    setSuccess(true);
                    setLoading(false);
                    return;
                  }
                } catch (error) {
                  console.log(`‚ö†Ô∏è Error checking ${courseName}:`, error.message);
                  // Continue to next course
                }
              }
            }
            
            // If still no certificate found, check one more time for selectedCertificate
            // (in case it was set after the initial check or there was a timing issue)
            if (!certificateData) {
              const retrySelectedCertificate = localStorage.getItem('selectedCertificate');
              if (retrySelectedCertificate) {
                try {
                  const retryCertificate = JSON.parse(retrySelectedCertificate);
                  if (retryCertificate && (retryCertificate.courseTitle || retryCertificate.courseName)) {
                    // Normalize certificate data
                    if (!retryCertificate.courseTitle && retryCertificate.courseName) {
                      retryCertificate.courseTitle = retryCertificate.courseName;
                    }
                    if (!retryCertificate.date && retryCertificate.completionDate) {
                      retryCertificate.date = retryCertificate.completionDate;
                    }
                    setCertificateData(retryCertificate);
                    setCourseCompleted(true);
                    setSuccess(true);
                    setLoading(false);
                    localStorage.removeItem('selectedCertificate');
                    localStorage.removeItem('courseCompleted');
                    localStorage.removeItem('completedCourseName');
                    localStorage.removeItem('lastGeneratedCertificate');
                    console.log('üéâ Found certificate on final retry:', retryCertificate);
                    return;
                  }
                } catch (error) {
                  console.error('Error parsing retry certificate:', error);
                }
              }
              
              // Only show error if we truly don't have a certificate AND we're not viewing a selected one
              const finalCheck = localStorage.getItem('selectedCertificate');
              if (!finalCheck) {
                setError('No certificates found. Please complete a course first to generate a certificate.');
              } else {
                console.log('‚ö†Ô∏è selectedCertificate still exists, will retry on next render');
                setLoading(false);
              }
            }
          }
        }
      } catch (error) {
        console.error('Failed to initialize certificate:', error);
        setError('Network error. Please try again.');
      } finally {
        setLoading(false);
      }
    };

    initializeCertificate();
  }, []);

  // Refresh module counts from course completion status
  useEffect(() => {
    const refreshModuleCounts = async () => {
      if (!certificateData?.courseTitle) return;

      const token = localStorage.getItem('authToken') || localStorage.getItem('token');
      if (!token) return;

      try {
        // Get user email from token
        let userEmail = '';
        try {
          const payload = JSON.parse(atob(token.split('.')[1]));
          userEmail = payload.email;
        } catch (e) {
          console.error('Error parsing token:', e);
          return;
        }

        // Check course completion status to get accurate module counts
        const response = await fetch(API_ENDPOINTS.CERTIFICATES.CHECK_COURSE_COMPLETION, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${token}`
          },
          body: JSON.stringify({
            courseName: certificateData.courseTitle,
            userEmail: userEmail
          })
        });

        const data = await response.json();
        if (response.ok && data.success) {
          // Try to get module counts from completionStatus first
          const completionStatus = data.completionStatus;
          if (completionStatus) {
            setRefreshedModuleData({
              completedModules: completionStatus.completedModules || certificateData.completedModules || [],
              totalModules: completionStatus.totalModules || certificateData.totalModules || 0,
              completedCount: completionStatus.completedCount || (Array.isArray(completionStatus.completedModules) ? completionStatus.completedModules.length : 0)
            });
            console.log('‚úÖ Refreshed module counts from completionStatus:', {
              completed: completionStatus.completedCount || (Array.isArray(completionStatus.completedModules) ? completionStatus.completedModules.length : 0),
              total: completionStatus.totalModules
            });
          } else if (data.certificate) {
            // Fallback: use certificate data from response if available
            const cert = data.certificate;
            setRefreshedModuleData({
              completedModules: cert.completedModules || certificateData.completedModules || [],
              totalModules: cert.totalModules || certificateData.totalModules || 0,
              completedCount: Array.isArray(cert.completedModules) ? cert.completedModules.length : (cert.completedModules || 0)
            });
            console.log('‚úÖ Refreshed module counts from certificate:', {
              completed: Array.isArray(cert.completedModules) ? cert.completedModules.length : (cert.completedModules || 0),
              total: cert.totalModules
            });
          }
        }
      } catch (error) {
        console.error('Error refreshing module counts:', error);
        // Use certificate data as fallback
        setRefreshedModuleData({
          completedModules: certificateData.completedModules || [],
          totalModules: certificateData.totalModules || 0,
          completedCount: Array.isArray(certificateData.completedModules) ? certificateData.completedModules.length : 0
        });
      }
    };

    if (certificateData) {
      refreshModuleCounts();
    }
  }, [certificateData]);

  // Auto-generate and display PDF when certificate data is available
  useEffect(() => {
    const autoGeneratePdf = async () => {
      if (certificateData && !loading && !error && !autoGeneratedPdfUrl) {
        try {
          console.log('üîÑ Auto-generating certificate PDF...');
          const pdfBytes = await generatePdfBytes();
          const blob = new Blob([pdfBytes], { type: 'application/pdf' });
          const blobUrl = window.URL.createObjectURL(blob);
          setAutoGeneratedPdfUrl(blobUrl);
          setPdfGenerated(true);
          console.log('‚úÖ Certificate PDF auto-generated and displayed');
        } catch (err) {
          console.error('‚ùå Error auto-generating certificate PDF:', err);
          setError('Unable to generate certificate PDF. Please try again.');
        }
      }
    };

    autoGeneratePdf();
  }, [certificateData, loading, error, autoGeneratedPdfUrl]);

  // Note: Loading and error states are handled in the main return statement below

  // Format date as DD/MM/YYYY
  const formatDate = (dateValue) => {
    if (!dateValue) {
      const today = new Date();
      const day = String(today.getDate()).padStart(2, '0');
      const month = String(today.getMonth() + 1).padStart(2, '0');
      const year = today.getFullYear();
      return `${day}/${month}/${year}`;
    }
    
    // If it's already a string, try to parse it
    if (typeof dateValue === 'string') {
      const parsedDate = new Date(dateValue);
      if (!isNaN(parsedDate.getTime())) {
        const day = String(parsedDate.getDate()).padStart(2, '0');
        const month = String(parsedDate.getMonth() + 1).padStart(2, '0');
        const year = parsedDate.getFullYear();
        return `${day}/${month}/${year}`;
      }
      // If parsing fails, return as is (might already be formatted)
      return dateValue;
    }
    
    // If it's a Date object
    if (dateValue instanceof Date) {
      const day = String(dateValue.getDate()).padStart(2, '0');
      const month = String(dateValue.getMonth() + 1).padStart(2, '0');
      const year = dateValue.getFullYear();
      return `${day}/${month}/${year}`;
    }
    
    return dateValue;
  };

  // Determine certificate type (pre-test vs pro/post-test)
  const certificateType =
    location.state?.fromPreTest ? 'pre' : 'pro';

  // Get certificate details - use refreshed data if available, otherwise use certificate data
  const courseTitle =
    location.state?.certificateDataOverride?.courseTitle ||
    certificateData?.courseTitle ||
    certificateData?.courseName ||
    "Training Program";
  const date = formatDate(
    location.state?.certificateDataOverride?.completionDate ||
      certificateData?.date ||
      certificateData?.completionDate
  );
  const certificateId = certificateData?.certificateId || "CERT-001";
  const currentYear = new Date().getFullYear();
  
  // Use refreshed module data if available, otherwise fall back to certificate data
  const completedModules = refreshedModuleData?.completedModules || certificateData?.completedModules || [];
  const totalModules = refreshedModuleData?.totalModules || certificateData?.totalModules || 0;
  
  // Calculate completed count - prefer array length if it's an array, otherwise use the count
  const completedCount = Array.isArray(completedModules) 
    ? completedModules.length 
    : (refreshedModuleData?.completedCount || (Array.isArray(certificateData?.completedModules) ? certificateData.completedModules.length : 0));

  // Cleanup PDF URL on unmount
  useEffect(() => {
    return () => {
      if (autoGeneratedPdfUrl) {
        window.URL.revokeObjectURL(autoGeneratedPdfUrl);
      }
      if (pdfPreviewUrl) {
        window.URL.revokeObjectURL(pdfPreviewUrl);
      }
    };
  }, [autoGeneratedPdfUrl, pdfPreviewUrl]);

  return (
    <div style={{ 
      width: '100%', 
      height: '100vh', 
      display: 'flex', 
      flexDirection: 'column',
      backgroundColor: '#f5f5f5',
      margin: 0,
      padding: 0
    }}>
      {/* Download button bar */}
      {autoGeneratedPdfUrl && (
        <div style={{
          position: 'fixed',
          top: 0,
          left: 0,
          right: 0,
          backgroundColor: '#fff',
          padding: '10px 20px',
          boxShadow: '0 2px 4px rgba(0,0,0,0.1)',
          zIndex: 1000,
          display: 'flex',
          justifyContent: 'flex-end',
          gap: '10px',
          alignItems: 'center'
        }}>
          <button
            onClick={async () => {
              try {
                const pdfBytes = await generatePdfBytes();
                const blob = new Blob([pdfBytes], { type: 'application/pdf' });
                const blobUrl = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = blobUrl;
                const sanitizedCourse = courseTitle.replace(/[\\/:*?"<>|]/g, '');
                const sanitizedName = (employeeName || 'Employee').replace(/[\\/:*?"<>|]/g, '');
                a.download = `Certificate - ${sanitizedName} - ${sanitizedCourse}.pdf`;
                document.body.appendChild(a);
                a.click();
                a.remove();
                window.URL.revokeObjectURL(blobUrl);
              } catch (err) {
                console.error('Error downloading certificate PDF:', err);
                alert('Unable to download PDF certificate. Please try again.');
              }
            }}
            style={{
              backgroundColor: '#007bff',
              color: 'white',
              border: 'none',
              padding: '10px 20px',
              borderRadius: '5px',
              cursor: 'pointer',
              fontSize: '14px',
              fontWeight: 'bold',
              display: 'flex',
              alignItems: 'center',
              gap: '8px'
            }}
          >
            ‚¨áÔ∏è Download PDF
          </button>
        </div>
      )}

      {/* PDF Viewer */}
      {autoGeneratedPdfUrl ? (
        <iframe
          src={autoGeneratedPdfUrl}
          title="Certificate"
          style={{
            width: '100%',
            height: '100vh',
            border: 'none',
            marginTop: autoGeneratedPdfUrl ? '50px' : '0'
          }}
        />
      ) : loading ? (
        <div style={{
          display: 'flex',
          justifyContent: 'center',
          alignItems: 'center',
          height: '100vh',
          flexDirection: 'column',
          gap: '20px'
        }}>
          <div style={{ fontSize: '18px', color: '#666' }}>Loading Certificate...</div>
          <div style={{ fontSize: '14px', color: '#999' }}>Please wait while we prepare your certificate.</div>
        </div>
      ) : error ? (
        <div style={{
          display: 'flex',
          justifyContent: 'center',
          alignItems: 'center',
          height: '100vh',
          flexDirection: 'column',
          gap: '20px',
          padding: '20px'
        }}>
          <div style={{ 
            backgroundColor: '#f8d7da', 
            color: '#721c24', 
            padding: '15px', 
            borderRadius: '8px', 
            border: '1px solid #f5c6cb',
            maxWidth: '500px'
          }}>
            <p style={{ margin: '0', fontSize: '16px' }}>{error}</p>
          </div>
          <button 
            onClick={() => window.location.reload()}
            style={{
              backgroundColor: '#007bff',
              color: 'white',
              padding: '10px 20px',
              border: 'none',
              borderRadius: '5px',
              cursor: 'pointer',
              fontSize: '14px'
            }}
          >
            üîÑ Try Again
          </button>
        </div>
      ) : null}
    </div>
  );
};

export default CertificatePage;
